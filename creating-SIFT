import cv2
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.image as mpimg



image = '/home/cot12/Documents/jup-pads/sky.jpeg'
Beginning_image = cv2.imread(image,0) #read image "0" for gray and "1" for colour

s = 2 #sigma value
k = 8  #size
c = -1
threshold = 1
def gauss_blur(size, sigma):

    """Function to mimic the 'fspecial' gaussian MATLAB function
    """
    x, y = np.mgrid[-size//2 + 1:size//2 + 1, -size//2 + 1:size//2 + 1]
    g = np.exp(-((x**2 + y**2)/(2.0*sigma**2)))
    return g/g.sum()


#pyrlvl[0] = cv2.filter2D(Beginning_image,c, gauss_blur(s,k))
#print (gauss_blur(8,5))
#plt.imshow(filter_image_Gblur3, cmap ='gray')
#cv2.imwrite('/home/cot12/Documents/jup-pads/sky-2.jpg', filter_image_Gblur1)

#create image size variant
doubled = cv2.resize(Beginning_image, None, fx = 2 , fy = 2)
normal = cv2.resize(doubled, None, fx = 2 , fy = 2)
half = cv2.resize(normal, None, fx = 2 , fy = 2)
quarter = cv2.resize(half, None, fx = 2 , fy = 2)

#create zero layer for pyramid
pyrlvl1 = np.zeros((doubled.shape[0], doubled.shape[1],6))
pyrlvl2 = np.zeros((normal.shape[0], normal.shape[1],6))
pyrlvl3 = np.zeros((half.shape[0], half.shape[1],6))
pyrlvl4 = np.zeros((quarter.shape[0], quarter.shape[1],6))

# create our Gaussian pyramid

Gblur = gauss_blur(s,k)
for i in range(0,6):
    if i == 0:
        pyrlvl1[:,:,i] = cv2.filter2D(doubled,c, Gblur)
        pyrlvl2[:,:,i] = cv2.filter2D(normal,c, Gblur)
        pyrlvl3[:,:,i] = cv2.filter2D(half,c, Gblur)
        pyrlvl4[:,:,i] = cv2.filter2D(quarter,c, Gblur)
    else:
        pyrlvl1[:,:,i] = cv2.filter2D(pyrlvl1[:,:,i-1],c, Gblur)
        pyrlvl2[:,:,i] = cv2.filter2D(pyrlvl2[:,:,i-1],c, Gblur)
        pyrlvl3[:,:,i] = cv2.filter2D(pyrlvl3[:,:,i-1],c, Gblur)
        pyrlvl4[:,:,i] = cv2.filter2D(pyrlvl4[:,:,i-1],c, Gblur)

#create zero layer for DoG images 
DoGlvl1 = np.zeros((doubled.shape[0], doubled.shape[1],5))
DoGlvl2 = np.zeros((normal.shape[0], normal.shape[1],5))
DoGlvl3 = np.zeros((half.shape[0], half.shape[1],5))
DoGlvl4 = np.zeros((quarter.shape[0], quarter.shape[1],5))


# create DoG layer
for i in range (0,5):
    DoGlvl1[:,:,i] = pyrlvl1[:,:,i+1] - pyrlvl1[:,:,i]
    DoGlvl2[:,:,i] = pyrlvl2[:,:,i+1] - pyrlvl2[:,:,i]
    DoGlvl3[:,:,i] = pyrlvl3[:,:,i+1] - pyrlvl3[:,:,i]
    DoGlvl4[:,:,i] = pyrlvl4[:,:,i+1] - pyrlvl4[:,:,i]
    
    
# create zero layer to store extrema location
Exlvl1 = np.zeros((doubled.shape[0], doubled.shape[1],3))
Exlvl2 = np.zeros((normal.shape[0], normal.shape[1],3))
Exlvl3 = np.zeros((half.shape[0], half.shape[1],3))
Exlvl4 = np.zeros((quarter.shape[0], quarter.shape[1],3))


for i in range(1,4):
    for j in range(1, doubled.shape[0] -1):
        for k in range(1, doubled.shape[1]-1):
            if np.absolute(DoGlvl1[j, k, i]) < threshold:
                continue
            maxima = DoGlvl1[j,k,i] > 0
            minima = DoGlvl1[j,k,i] < 0
            for di in range(-1,1):
                for dj in range(-1,1):
                    for dk in range(-1,1):
                        if di == 0 and dj ==0 and dk == 0:
                            continue
                        maxima = maxima and (DoGlvl1[j, k, i] > DoGlvl1[j + dj, k + dk, i + di])
                        minima = minima and (DoGlvl1[j, k, i] < DoGlvl1[j + dj, k + dk, i + di])
                        
                        if not maxima and not minima:
                            break

                    if not maxima and not minima:
                        break

                if not maxima and not minima:
                    break
            if maxima or minima:
                dx = (DoGlvl1[j, k+1, i] - DoGlvl1[j, k-1, i]) * 0.5 / 255
                dy = (DoGlvl1[j+1, k, i] - DoGlvl1[j-1, k, i]) * 0.5 / 255
                dz = (DoGlvl1[j, k, i+1] - DoGlvl1[j, k, i-1]) * 0.5 / 255
                dxx = (DoGlvl1[j, k+1, i] + DoGlvl1[j, k-1, i] - 2 * DoGlvl1[j, k, i]) * 1.0 / 255        
                dyy = (DoGlvl1[j+1, k, i] + DoGlvl1[j-1, k, i] - 2 * DoGlvl1[j, k, i]) * 1.0 / 255          
                dzz = (DoGlvl1[j, k, i+1] + DoGlvl1[j, k, i-1] - 2 * DoGlvl1[j, k, i]) * 1.0 / 255
                dxy = (DoGlvl1[j+1, k+1, i] - DoGlvl1[j+1, k-1, i] - DoGlvl1[j-1, k+1, i] + DoGlvl1[j-1, k-1, i]) * 0.25 / 255 
                dxz = (DoGlvl1[j, k+1, i+1] - DoGlvl1[j, k-1, i+1] - DoGlvl1[j, k+1, i-1] + DoGlvl1[j, k-1, i-1]) * 0.25 / 255 
                dyz = (DoGlvl1[j+1, k, i+1] - DoGlvl1[j-1, k, i+1] - DoGlvl1[j+1, k, i-1] + DoGlvl1[j-1, k, i-1]) * 0.25 / 255  
                
                
                diff = np.matrix([[dx], [dy], [dz]])
                doublediff = np.matrix([[dxx, dxy, dxz], [dxy, dyy, dyz], [dxz, dyz, dzz]]) 
                least_sq = np.linalg.lstsq(diff, doublediff)[0] #function finds the sum of least squares 
                # least_sq = [S1,S2,S3]
                least_diff = DoGlvl1[j, k, i] + 0.5 * np.dot(diff, least_sq)
                r = 10.0
                if [(((dxx + dyy) ** 2) * r) < (dxx * dyy - (dxy ** 2)) * (((r + 1) ** 2)) and np.absolute(least_diff) > 0.03]: 
                    Exlvl1[j, k, i - 1] = 1


for i in range(1,4):
    for j in range(1, normal.shape[0] -1):
        for k in range(1, normal.shape[1]-1):
            if np.absolute(DoGlvl2[j, k, i]) < threshold:
                continue
            maxima = DoGlvl2[j,k,i] > 0
            minima = DoGlvl2[j,k,i] < 0
            for di in range(-1,1):
                for dj in range(-1,1):
                    for dk in range(-1,1):
                        if di == 0 and dj ==0 and dk == 0:
                            continue
                        maxima = maxima and (DoGlvl2[j, k, i] > DoGlvl2[j + dj, k + dk, i + di])
                        minima = minima and (DoGlvl2[j, k, i] < DoGlvl2[j + dj, k + dk, i + di])
                        
                        if not maxima and not minima:
                            break

                    if not maxima and not minima:
                        break

                if not maxima and not minima:
                    break
            if maxima or minima:
                dx = (DoGlvl2[j, k+1, i] - DoGlvl2[j, k-1, i]) * 0.5 / 255
                dy = (DoGlvl2[j+1, k, i] - DoGlvl2[j-1, k, i]) * 0.5 / 255
                dz = (DoGlvl2[j, k, i+1] - DoGlvl2[j, k, i-1]) * 0.5 / 255
                dxx = (DoGlvl2[j, k+1, i] + DoGlvl2[j, k-1, i] - 2 * DoGlvl2[j, k, i]) * 1.0 / 255        
                dyy = (DoGlvl2[j+1, k, i] + DoGlvl2[j-1, k, i] - 2 * DoGlvl2[j, k, i]) * 1.0 / 255          
                dzz = (DoGlvl2[j, k, i+1] + DoGlvl2[j, k, i-1] - 2 * DoGlvl2[j, k, i]) * 1.0 / 255
                dxy = (DoGlvl2[j+1, k+1, i] - DoGlvl2[j+1, k-1, i] - DoGlvl2[j-1, k+1, i] + DoGlvl2[j-1, k-1, i]) * 0.25 / 255 
                dxz = (DoGlvl2[j, k+1, i+1] - DoGlvl2[j, k-1, i+1] - DoGlvl2[j, k+1, i-1] + DoGlvl2[j, k-1, i-1]) * 0.25 / 255 
                dyz = (DoGlvl2[j+1, k, i+1] - DoGlvl2[j-1, k, i+1] - DoGlvl2[j+1, k, i-1] + DoGlvl2[j-1, k, i-1]) * 0.25 / 255  
                
                
                diff = np.matrix([[dx], [dy], [dz]])
                doublediff = np.matrix([[dxx, dxy, dxz], [dxy, dyy, dyz], [dxz, dyz, dzz]]) 
                least_sq = np.linalg.lstsq(diff, doublediff)[0] #function finds the sum of least squares 
                # least_sq = [S1,S2,S3]
                least_diff = DoGlvl2[j, k, i] + 0.5 * np.dot(diff, least_sq)
                r = 10.0
                if [(((dxx + dyy) ** 2) * r) < (dxx * dyy - (dxy ** 2)) * (((r + 1) ** 2)) and np.absolute(least_diff) > 0.03]: 
                    Exlvl2[j, k, i - 1] = 1
                 

for i in range(1,4):
    for j in range(1, half.shape[0] -1):
        for k in range(1, half.shape[1]-1):
            if np.absolute(DoGlvl3[j, k, i]) < threshold:
                continue
            maxima = DoGlvl3[j,k,i] > 0
            minima = DoGlvl3[j,k,i] < 0
            for di in range(-1,1):
                for dj in range(-1,1):
                    for dk in range(-1,1):
                        if di == 0 and dj ==0 and dk == 0:
                            continue
                        maxima = maxima and (DoGlvl3[j, k, i] > DoGlvl3[j + dj, k + dk, i + di])
                        minima = minima and (DoGlvl3[j, k, i] < DoGlvl3[j + dj, k + dk, i + di])
                        
                        if not maxima and not minima:
                            break

                    if not maxima and not minima:
                        break

                if not maxima and not minima:
                    break
            if maxima or minima:
                dx = (DoGlvl3[j, k+1, i] - DoGlvl3[j, k-1, i]) * 0.5 / 255
                dy = (DoGlvl3[j+1, k, i] - DoGlvl3[j-1, k, i]) * 0.5 / 255
                dz = (DoGlvl3[j, k, i+1] - DoGlvl3[j, k, i-1]) * 0.5 / 255
                dxx = (DoGlvl3[j, k+1, i] + DoGlvl3[j, k-1, i] - 2 * DoGlvl3[j, k, i]) * 1.0 / 255        
                dyy = (DoGlvl3[j+1, k, i] + DoGlvl3[j-1, k, i] - 2 * DoGlvl3[j, k, i]) * 1.0 / 255          
                dzz = (DoGlvl3[j, k, i+1] + DoGlvl3[j, k, i-1] - 2 * DoGlvl3[j, k, i]) * 1.0 / 255
                dxy = (DoGlvl3[j+1, k+1, i] - DoGlvl3[j+1, k-1, i] - DoGlvl3[j-1, k+1, i] + DoGlvl3[j-1, k-1, i]) * 0.25 / 255 
                dxz = (DoGlvl3[j, k+1, i+1] - DoGlvl3[j, k-1, i+1] - DoGlvl3[j, k+1, i-1] + DoGlvl3[j, k-1, i-1]) * 0.25 / 255 
                dyz = (DoGlvl3[j+1, k, i+1] - DoGlvl3[j-1, k, i+1] - DoGlvl3[j+1, k, i-1] + DoGlvl3[j-1, k, i-1]) * 0.25 / 255  
                
                
                diff = np.matrix([[dx], [dy], [dz]])
                doublediff = np.matrix([[dxx, dxy, dxz], [dxy, dyy, dyz], [dxz, dyz, dzz]]) 
                least_sq = np.linalg.lstsq(diff, doublediff)[0] #function finds the sum of least squares 
                # least_sq = [S1,S2,S3]
                least_diff = DoGlvl3[j, k, i] + 0.5 * np.dot(diff, least_sq)
                r = 10.0
                if [(((dxx + dyy) ** 2) * r) < (dxx * dyy - (dxy ** 2)) * (((r + 1) ** 2)) and np.absolute(least_diff) > 0.03]: 
                    Exlvl3[j, k, i - 1] = 1
                                 
                
                
for i in range(1,4):
    for j in range(1, quarter.shape[0] -1):
        for k in range(1, quarter.shape[1]-1):
            if np.absolute(DoGlvl4[j, k, i]) < threshold:
                continue
            maxima = DoGlvl4[j,k,i] > 0
            minima = DoGlvl4[j,k,i] < 0
            for di in range(-1,1):
                for dj in range(-1,1):
                    for dk in range(-1,1):
                        if di == 0 and dj ==0 and dk == 0:
                            continue
                        maxima = maxima and (DoGlvl4[j, k, i] > DoGlvl4[j + dj, k + dk, i + di])
                        minima = minima and (DoGlvl4[j, k, i] < DoGlvl4[j + dj, k + dk, i + di])
                        
                        if not maxima and not minima:
                            break

                    if not maxima and not minima:
                        break

                if not maxima and not minima:
                    break
            if maxima or minima:
                dx = (DoGlvl4[j, k+1, i] - DoGlvl4[j, k-1, i]) * 0.5 / 255
                dy = (DoGlvl4[j+1, k, i] - DoGlvl4[j-1, k, i]) * 0.5 / 255
                dz = (DoGlvl4[j, k, i+1] - DoGlvl4[j, k, i-1]) * 0.5 / 255
                dxx = (DoGlvl4[j, k+1, i] + DoGlvl4[j, k-1, i] - 2 * DoGlvl4[j, k, i]) * 1.0 / 255        
                dyy = (DoGlvl4[j+1, k, i] + DoGlvl4[j-1, k, i] - 2 * DoGlvl4[j, k, i]) * 1.0 / 255          
                dzz = (DoGlvl4[j, k, i+1] + DoGlvl4[j, k, i-1] - 2 * DoGlvl4[j, k, i]) * 1.0 / 255
                dxy = (DoGlvl4[j+1, k+1, i] - DoGlvl4[j+1, k-1, i] - DoGlvl4[j-1, k+1, i] + DoGlvl4[j-1, k-1, i]) * 0.25 / 255 
                dxz = (DoGlvl4[j, k+1, i+1] - DoGlvl4[j, k-1, i+1] - DoGlvl4[j, k+1, i-1] + DoGlvl4[j, k-1, i-1]) * 0.25 / 255 
                dyz = (DoGlvl4[j+1, k, i+1] - DoGlvl4[j-1, k, i+1] - DoGlvl4[j+1, k, i-1] + DoGlvl4[j-1, k, i-1]) * 0.25 / 255  
                
                
                diff = np.matrix([[dx], [dy], [dz]])
                doublediff = np.matrix([[dxx, dxy, dxz], [dxy, dyy, dyz], [dxz, dyz, dzz]]) 
                least_sq = np.linalg.lstsq(diff, doublediff)[0] #function finds the sum of least squares 
                # least_sq = [S1,S2,S3]
                least_diff = DoGlvl4[j, k, i] + 0.5 * np.dot(diff, least_sq)
                r = 10.0
                if [(((dxx + dyy) ** 2) * r) < (dxx * dyy - (dxy ** 2)) * (((r + 1) ** 2)) and np.absolute(least_diff) > 0.03]: 
                    Exlvl4[j, k, i - 1] = 1
                 


                                                 
print("Number of extrema in first octave: %d" % np.sum(Exlvl1))
print("Number of extrema in second octave: %d" % np.sum(Exlvl2))
print("Number of extrema in third octave: %d" % np.sum(Exlvl3))
print("Number of extrema in fourth octave: %d" % np.sum(Exlvl4))

# Gradient magnitude and orientation for each image sample point at each scale
Grmaglvl1 = np.zeros((doubled.shape[0], doubled.shape[1], 3))
Grmaglvl2 = np.zeros((normal.shape[0], normal.shape[1], 3))
Grmaglvl3 = np.zeros((half.shape[0], half.shape[1], 3))
Grmaglvl4 = np.zeros((quarter.shape[0], quarter.shape[1], 3))

Orientlvl1 = np.zeros((doubled.shape[0], doubled.shape[1], 3))
Orientlvl2 = np.zeros((normal.shape[0], normal.shape[1], 3))
Orientlvl3 = np.zeros((half.shape[0], half.shape[1], 3))
Orientlvl4 = np.zeros((quarter.shape[0], quarter.shape[1], 3))

for i in range(0,3):
    for j in range(0, doubled.shape[0]-1):
        for k in range(0, doubled.shape[1]-1):
            Grmaglvl1[j,k,i] = (((doubled[j+1,k] - doubled[j-1,k])**2) + ((doubled[j,k+1] - doubled[j,k-1])**2))**0.5
            Orientlvl1[j,k,i] = np.arctan((doubled[j,k+1] - doubled[j,k-1]) / (doubled[j+1,k] - doubled[j-1,k]))


for i in range(0,3):
    for j in range(0, normal.shape[0]-1):
        for k in range(0, normal.shape[1]-1):
            Grmaglvl2[j,k,i] = (((normal[j+1,k] - normal[j-1,k])**2) + ((normal[j,k+1] - normal[j,k-1])**2))**0.5
            Orientlvl2[j,k,i] = np.arctan((normal[j,k+1] - normal[j,k-1]) / (normal[j+1,k] - normal[j-1,k]))
            

for i in range(0,3):
    for j in range(0, half.shape[0]-1):
        for k in range(0, half.shape[1]-1):
            Grmaglvl3[j,k,i] = (((half[j+1,k] - half[j-1,k])**2) + ((half[j,k+1] - half[j,k-1])**2))**0.5
            Orientlvl3[j,k,i] = np.arctan((half[j,k+1] - half[j,k-1]) / (half[j+1,k] - half[j-1,k]))
            
for i in range(0,3):
    for j in range(0, quarter.shape[0]-1):
        for k in range(0, quarter.shape[1]-1):
            Grmaglvl3[j,k,i] = (((quarter[j+1,k] - quarter[j-1,k])**2) + ((quarter[j,k+1] - quarter[j,k-1])**2))**0.5
            Orientlvl3[j,k,i] = np.arctan((quarter[j,k+1] - quarter[j,k-1]) / (quarter[j+1,k] - quarter[j-1,k]))

            
extr_sum = np.sum(Exlvl1) + np.sum(Exlvl2) + np.sum(Exlvl3) + np.sum(Exlvl4)
keypoints = np.zeros((extr_sum, 4)) 

print("Calculating keypoint orientations...")
count = 0
